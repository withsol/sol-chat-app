export async function POST(request) {
  console.log('=== PROCESSING BUSINESS PLAN WITH ENHANCED PERSONALGORITHM™ ===')
  
  try {
    const { email, businessPlanText, planData = null } = await request.json()
    
    if (!email || !businessPlanText) {
      return NextResponse.json({ 
        error: 'Email and business plan text required' 
      }, { status: 400 })
    }

    console.log('Processing enhanced business plan for user:', email)

    // Step 1: Create business plan entry (if planData provided)
    let businessPlanEntry = null
    if (planData) {
      businessPlanEntry = await createBusinessPlanEntry(email, planData)
    }
    
    // Step 2: Run sophisticated Personalgorithm™ analysis on the business plan content
    const personalgorithmResponse = await fetch(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/analyze-personalgorithm`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email,
        sourceText: businessPlanText,
        sourceType: 'business-plan',
        analysisType: 'strategic'
      })
    })
    
    let personalgorithmResult = { entriesCreated: 0, createdEntries: [] }
    if (personalgorithmResponse.ok) {
      personalgorithmResult = await personalgorithmResponse.json()
    }
    
    // Step 3: Update user profile with business context
    const profileUpdates = {}
    if (planData?.topGoals) {
      profileUpdates['Current Goals'] = planData.topGoals
    }
    
    // Add business planning tags
    const existingProfile = await getUserProfile(email)
    const existingTags = existingProfile?.['Tags'] || ''
    const newTags = 'business-plan-analyzed, strategic-planning, personalgorithm-enhanced'
    profileUpdates['Tags'] = existingTags ? `${existingTags}, ${newTags}` : newTags
    
    if (Object.keys(profileUpdates).length > 0) {
      await updateUserProfile(email, profileUpdates)
    }

    console.log('✅ Enhanced business plan processing completed')

    return NextResponse.json({
      success: true,
      businessPlanEntry: businessPlanEntry,
      profileUpdates: profileUpdates,
      personalgorithmInsights: personalgorithmResult.entriesCreated,
      personalgorithmCategories: personalgorithmResult.categories || [],
      message: `Business plan processed! Created ${personalgorithmResult.entriesCreated} detailed Personalgorithm™ insights from your strategic content.`
    })

  } catch (error) {
    console.error('❌ Enhanced business plan processing error:', error)
    return NextResponse.json({
      error: 'Failed to process business plan with enhanced analysis',
      details: error.message
    }, { status: 500 })
  }
}

// Helper funtions //

async function fetchUserContextForPersonalgorithm(email) {
  try {
    const [userProfile, recentMessages, existingPersonalgorithm] = await Promise.allSettled([
      getUserProfile(email),
      getRecentMessages(email, 5),
      getPersonalgorithmData(email, 5)
    ])

    const context = {
      userProfile: userProfile.status === 'fulfilled' ? userProfile.value : null,
      recentMessages: recentMessages.status === 'fulfilled' ? recentMessages.value : [],
      existingPersonalgorithm: existingPersonalgorithm.status === 'fulfilled' ? existingPersonalgorithm.value : []
    }

    let summary = "USER CONTEXT FOR PERSONALGORITHM™ ANALYSIS:\n\n"
    
    if (context.userProfile) {
      summary += `Current Vision: ${context.userProfile['Current Vision'] || 'Not set'}\n`
      summary += `Current State: ${context.userProfile['Current State'] || 'Not set'}\n`
      summary += `Tags: ${context.userProfile['Tags'] || 'None'}\n\n`
    }
    
    if (context.existingPersonalgorithm.length > 0) {
      summary += "EXISTING PERSONALGORITHM™ PATTERNS:\n"
      context.existingPersonalgorithm.slice(0, 3).forEach((entry, i) => {
        summary += `${i + 1}. ${entry.notes}\n`
      })
    }
    
    context.contextSummary = summary
    return context

  } catch (error) {
    console.error('Error fetching user context for Personalgorithm™:', error)
    return { contextSummary: 'Limited context available' }
  }
}

function parsePersonalgorithmAnalysis(analysis) {
  const categories = [
    'COMMUNICATION_PATTERNS',
    'DECISION_MAKING_STYLE', 
    'TRANSFORMATION_TRIGGERS',
    'EMOTIONAL_PATTERNS',
    'BUSINESS_MINDSET',
    'PROCESSING_STYLE',
    'STRENGTHS_LEVERAGE',
    'GROWTH_EDGES',
    'UNIQUE_FACTORS'
  ]

  const insights = {}

  for (const category of categories) {
    const match = analysis.match(new RegExp(`${category}: \\[([\\s\\S]*?)\\]`))
    if (match) {
      insights[category] = match[1]
        .split('\n')
        .map(line => line.replace(/^["\s,-]+|["\s,-]+$/g, '').trim())
        .filter(line => line.length > 20)
    } else {
      insights[category] = []
    }
  }

  return insights
}

async function createPersonalgorithmEntry(email, notes, tags = ['auto-generated']) {
  try {
    const userRecordId = await getUserRecordId(email)
    if (!userRecordId) return null

    const personalgorithmId = `p_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    const response = await fetch(`https://api.airtable.com/v0/${process.env.AIRTABLE_BASE_ID}/Personalgorithm™`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.AIRTABLE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        fields: {
          'Personalgorithm™ ID': personalgorithmId,
          'User': email,
          'Personalgorithm™ Notes': notes,
          'Date created': new Date().toISOString(),
          'Tags': Array.isArray(tags) ? tags.join(', ') : tags
        }
      })
    })

    if (response.ok) {
      const result = await response.json()
      console.log('✅ Personalgorithm™ entry created:', result.id)
      return result
    }
    return null
  } catch (error) {
    console.error('Error creating Personalgorithm™ entry:', error)
    return null
  }
}